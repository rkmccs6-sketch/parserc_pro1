# C语言函数解析器 (parsercfc) 项目文档

## 总体介绍

### 项目概述
本项目是一个专为 Linux 环境设计的高性能 C 语言源代码解析工具。它的核心目标是解决在大规模 C 语言工程（如 Linux 内核、FFmpeg、QEMU 等）中，快速、准确地提取所有 `.c` 源文件中定义的函数名（Function Definitions）的需求。

与基于正则表达式的简单匹配不同，本项目采用 **Flex (Lex)** 和 **Bison (Yacc)** 构建了完整的词法和语法分析器，结合 **Python** 的多进程调度能力，能够处理复杂的 C 语言语法结构、宏定义干扰以及不规范的代码风格。

### 核心技术与功能
* **LALR(1) 语法分析**：基于 Bison 构建语法树，能够精准区分“函数声明”与“函数定义”，自动忽略结构体、全局变量和局部变量。
* **关注点分离架构**：采用模块化设计，将核心语法规则（Bison）与语义动作逻辑（C Utils）分离，极大地提高了代码的可维护性和扩展性。
* **智能宏处理**：内置轻量级宏识别机制，能自动跳过 `static`, `inline`, `__attribute__`, `av_cold` (FFmpeg常见) 等类型修饰宏，防止解析错误。
* **高性能并发**：使用 Python `concurrent.futures` 模块实现多进程并行解析，充分利用多核 CPU 优势，大幅提升海量文件的扫描速度。
* **结构化输出**：解析结果统一输出为 JSON 格式，清晰区分包含函数的文件和无函数的文件，便于下游工具集成。

### 项目目录结构
```text
parsercfc/              # 项目根目录
├── bin/                # 存放编译生成的 Python 包装脚本及可执行文件
├── build/              # 存放编译过程中的中间文件 (.o, .c generated by flex/bison)
├── images/             # README.md中的图片
├── src/                # 源代码目录
│   ├── lexer.l         # Flex 词法定义文件 (处理 Token 和预处理)
│   ├── parser.y        # Bison 语法定义文件 (纯粹的文法规则)
│   ├── utils.c         # C 工具库 (实现宏处理、字符串拼接、辅助逻辑)
│   ├── utils.h         # C 工具库头文件
│   ├── cfc_parser.c    # C 语言主程序入口 (调用 yyparse)
│   └── parsercfc.py    # Python 驱动脚本 (CLI 入口，负责多进程调度)
├── test/               # 测试数据与结果
│   ├── in/             # 测试输入目录 (如 FFmpeg 源码)
│   └── out/            # 测试输出目录 (fc.json, null_fc.json, run.log)
├── Makefile            # 项目自动化构建脚本
└── README.md           # 项目说明文档
```

## 技术实现

本项目采用 **C/C++ (核心解析引擎)** + **Python (业务调度层)** 的混合架构，并严格遵循“机制与策略分离”的原则。

### 词法分析 (Lexer) - `src/lexer.l`

词法分析器（Lexer）是解析流程的第一步，由 **Flex** 生成。它的主要职责是将 C 语言源代码字符流转换为语法分析器（Parser）可理解的 Token 流。为了适应复杂的工业级 C 代码（如 FFmpeg），本项目的 Lexer 包含了一些特殊的设计策略。

#### 核心状态机设计
为了处理 C 语言的嵌套结构和预处理指令，Lexer 定义了多个独占状态（Exclusive States, `%x`）：
* **INITIAL**: 默认状态，处理全局作用域的 Token。
* **PREPROC / PREPROC_DEFINE**: 预处理状态。用于捕获 `#define` 指令，处理多行连接符（`\`），提取宏定义内容。
* **BRACE**: 函数体/代码块状态。当检测到左大括号 `{` 时进入此状态，用于快速跳过函数体。
* **COMMENT / BRACE_COMMENT**: 注释状态。用于安全地忽略 `/* ... */` 块注释，防止注释内的关键字干扰解析。
* **BRACE_STRING / BRACE_CHAR**: 字符串/字符状态。用于在跳过代码块时，正确处理字符串内的转义字符和引号，避免提前误匹配右大括号 `}`。

#### 关键特性实现

**A. 预处理模拟 (Preprocessor Simulation)**

* **背景**：标准的 Parser 通常在预处理之后运行，但为了简化工具链，本项目直接分析源码。
* **实现**：
    * 当匹配到 `^# define` 时，进入 `PREPROC_DEFINE` 状态。
    * 利用 `pp_append` 函数将多行宏定义（通过 `\` 换行）拼接完整。
    * 调用 `macro_register_definition()` 将宏注册到全局符号表。这使得 Parser 后续能识别像 `MACRO_FUNC(x)` 这样展开后即为函数定义的宏。

**B. 函数体快速跳过 (Body Skipping Optimization)**

* **背景**：本项目只关注“函数签名”（即函数名和参数表），函数体内部的局部变量、逻辑控制对提取函数名没有意义，且解析它们会消耗大量资源。
* **实现**：
    * **深度计数**：维护全局变量 `brace_depth`。
    * **进入条件**：在 `INITIAL` 状态遇到 `{`，`brace_depth` 置 1，进入 `BRACE` 状态。
    * **跳过逻辑**：在 `BRACE` 状态下，忽略绝大多数 Token（如关键字、运算符），仅关注 `{` (深度+1) 和 `}` (深度-1)。
    * **退出条件**：当 `brace_depth` 归零时，返回一个虚拟的 `BLOCK` Token 给 Parser，并切回 `INITIAL` 状态。
    * **效果**：解析复杂度从 O(CodeSize) 降低到 O(SignatureSize)，极大提升了性能。

**C. 动态宏识别 (Dynamic Macro Lookup)**

* **背景**：FFmpeg 等项目常用宏来定义函数，或者用宏修饰函数（如 `static av_cold`）。
* **实现**：
    * 在匹配 `[a-zA-Z_][a-zA-Z0-9_]*` (标识符) 时，动作代码不仅仅返回 `IDENTIFIER`。
    * 它会先调用 `macro_lookup_token(yytext)` 查询符号表。
    * 如果该标识符是一个已知的“函数定义宏”（如 `MACRO_TEMPLATE`），则返回对应的特殊 Token；否则才返回普通 `IDENTIFIER`。这赋予了 Lexer 上下文敏感的能力。

### 语法分析 (Parser) - `src/parser.y`

语法分析器（Parser）是本项目的核心组件，由 **Bison** 生成。它接收 Lexer 产生的 Token 流，根据预定义的 **LALR(1)** 文法规则构建语法结构，并最终提取出函数名。

为了在处理不规范或高度宏化的 C 代码（如内核驱动、FFmpeg）时保持健壮性，本 Parser 采用了 **"宽松解析 + 后置校验"** 的设计策略。

#### 核心设计策略

**A. 顶层文法聚焦 (Top-Level Grammar Focus)**
* Parser 并不尝试理解 C 语言的所有细节（如表达式求值、复杂的类型转换）。
* 它只关注 **"顶层定义" (Top-Level Definitions)**，即全局作用域下的函数定义、宏调用和全局变量声明。
* 函数体内部的逻辑通过 Lexer 的 `BLOCK` Token 直接略过，极大降低了文法复杂度，避免了因内部语法错误导致的解析中断。

**B. 签名重构 (Signature Reconstruction)**
* 由于 C 语言的类型声明可能非常复杂（如函数指针、多级指针、数组修饰符），Parser 在匹配 `signature` 规则时，并不立即构建抽象语法树（AST）。
* 而是采用 **字符串拼接** 的方式，将匹配到的 Token（类型、标识符、指针星号等）动态拼接成一个完整的函数签名字符串。
* **优势**：这种方法能原样保留代码中的修饰符（如 `__attribute__`），为后续的精确分析提供完整上下文。

**C. 宏与非标准语法支持**
* **宏模板识别**：通过 `MACRO_TEMPLATE` 规则，能够解析形如 `DECLARE_FUNC(my_func)` 的宏展开式函数定义。
* **重命名机制**：支持 `MACRO_RENAME`（如 FFmpeg 的 `fn()` 宏）和 `ARRAY_RENAME`，能够正确还原被宏混淆的真实函数名。
* **修饰符穿透**：文法规则允许在函数返回类型和函数名之间插入任意数量的修饰符（`static`, `inline`, `av_cold` 等），确保解析不会因非标准关键字而失败。

#### 关键处理流程

1.  **Token传入**：接收 Lexer 传入的 Token（如 `INT`, `IDENTIFIER`, `MACRO_CALL` 等）。
2.  **规则匹配**：
    * **函数定义**：匹配 `signature + BLOCK` 结构。成功匹配后，将完整的 `signature` 字符串传递给 `utils.c` 中的 `check_and_record()`。
    * **宏定义**：匹配 `PP_DEFINE`，将宏内容注册到全局符号表，用于辅助 Lexer 的后续识别。
3.  **后置校验 (Validation)**：
    * 在 `check_and_record()` 中，对提取出的签名字串进行清洗。
    * 剔除 `if (...)`, `while (...)` 等可能被误判为函数定义的控制流语句。
    * 最终提取出纯净的函数名并存入结果链表。

### 核心逻辑库 (Utils) - `src/utils.c`

`src/utils.c` 是本项目的**语义处理引擎**，其对应的头文件为`src/utils.h`。`src/utils.c` 负责处理所有复杂的语义动作、内存管理、宏逻辑运算以及最终结果的清洗与校验。

该模块实现了**机制与策略分离**，使得 Parser 的文法规则保持简洁，而将复杂的 C 语言语义处理封装在 C 函数中。

**A. 智能宏系统 (Intelligent Macro System)**
为了解决 C 语言中“宏即函数”或“宏修饰函数”的解析难题，Utils 内部实现了一个微型预处理器：

* **宏注册 (`macro_register_definition`)**：解析 `#define` 指令，自动识别宏是“重命名宏”（如 `#define FN(x) x`）还是“函数模板宏”（如 `#define DEFINE_TEST(name) ...`）。它会提取宏参数和展开体模式。
* **宏词法分析 (`macro_next_token`)**：内置了一个专门针对宏展开体的微型 Tokenizer，支持识别 `##` 连接符、字符串化等操作。
* **宏展开与渲染 (`render_macro_name`)**：当 Parser 遇到宏调用时，该模块结合传入的实参（Arguments）和预存的宏模板，动态生成展开后的函数名。这使得解析器能理解 `SYSCALL_DEFINE3(open, ...)` 实际上定义了 `sys_open` 函数。

**B. 结果清洗与校验 (Sanitization & Validation)**
* **背景**：Parser 采用宽松匹配策略，可能会误将 `if (condition)` 或 `while (loop)` 识别为函数调用。
* **实现 (`check_and_record`)**：
    * **空白清洗**：去除签名字符串中多余的空格和换行。
    * **关键字过滤**：检查提取出的“函数名”是否为 C 语言保留关键字（如 `if`, `for`, `switch`, `return` 等）。
    * **合法性检查**：确保函数名符合 C 语言标识符规范（字母/下划线开头）。
    * **去重与存储**：将合法的函数名存入内存链表，供后续 JSON 序列化使用。

**C. 安全字符串操作 (Safe String Operations)**
* C 语言的字符串拼接容易导致内存泄漏或缓冲区溢出。本模块封装了 `concat` 和 `concat_with_space` 等工具函数，统一管理内存分配（`malloc`/`realloc`），确保在拼接长函数签名时的安全性。

**D. 状态管理 (State Management)**
* 支持批量解析模式。通过 `parser_reset_state()`，在处理完一个文件后彻底清理符号表和内存池，防止不同文件间的宏定义相互污染，确保多文件解析的独立性和准确性。

### 主程序与输出 (Main & Output) - `src/cfc_parser.c`

`src/cfc_parser.c` 是编译后的二进制程序 `cfc_parser` 的入口点，负责控制流程的启动、停止以及结果的交付。

#### 核心职责

**A. 流程控制 (Flow Control)**

* **文件驱动**：打开指定的 `.c` 源文件，将其文件指针 `yyin` 传递给 Flex 生成的扫描器。
* **复位机制**：在处理每个新文件之前，调用 `lexer_reset()` 和 `parser_reset_state()`（来自 `utils.c`）。这对于 `--batch` 模式至关重要，确保上一个文件的宏定义或状态不会污染当前文件的解析。
* **解析触发**：调用 `yyparse()` 启动语法分析流程。

**B. 数据收集 (Data Collection)**
* **回调接口 (`record_function`)**：这是 Parser 与 Main 之间的桥梁。当 Parser 在语法层面上确认一个函数定义时，会调用此函数。
* **暂存容器 (`FunctionList`)**：维护一个动态增长的字符串数组，用于暂存当前文件解析到的所有函数名。

**C. JSON 序列化 (JSON Serialization)**
* **格式化输出**：不依赖庞大的第三方 JSON 库，而是内置了一个轻量级的 JSON 生成器。
* **字符转义**：实现了 `json_escape_and_print` 函数，能够正确处理函数名中可能出现的特殊字符（尽管在规范 C 中很少见，但为了鲁棒性必须处理），确保生成的 JSON 符合标准。

#### 运行模式

* **单文件模式**：`cfc_parser file.c`
    * 输出：直接打印一个 JSON 数组 `["func1", "func2"]`。
    * 用途：调试或简单脚本调用。
* **批处理模式**：`cfc_parser --batch file1.c file2.c ...`
    * 输出：为每个文件打印一行独立的 JSON 对象 `{"path": "...", "fc": [...]}`。
    * 用途：`parsercfc.py` 默认使用此模式，通过减少进程创建开销来极大提升大规模扫描时的性能。

### 驱动与调度 (Driver) - `src/parsercfc.py`

`src/parsercfc.py` 是用户直接交互的命令行工具（CLI）。它采用 **Python** 编写，主要职责是屏蔽多进程并发、文件搜索和二进制调用的复杂性，为用户提供简洁的统一接口。

**A. 智能并发调度 (Intelligent Concurrency)**

* **多进程池 (`ProcessPoolExecutor`)**：利用 Python 的 `concurrent.futures` 模块建立进程池。
* **自动负载均衡**：默认根据 CPU 核心数自动计算 Worker 数量（`CPU - 1`），既能充分榨干多核性能，又保留一个核心给系统响应，防止死机。
* **任务分发**：将待解析的文件列表分割成多个“任务块”（Chunks），分发给不同的 Worker 并行处理。

**B. 批处理优化 (Batch Processing Optimization)**
* **减少开销**：如果对每个 `.c` 文件都启动一次 C 进程（`fork/exec`），系统开销将非常巨大。
* **批量传递**：本脚本实现了 `--batch` 策略，一次性将数十个文件路径传递给底层的 `cfc_parser`。C 解析器在一次启动中连续处理这些文件，极大降低了进程创建/销毁的频率，性能提升显著。

**C. 健壮性设计 (Robustness)**
* **二进制探测 (`resolve_parser_binary`)**：能够智能查找编译后的 `cfc_parser` 二进制文件（支持开发环境目录 `build/`、安装目录同级查找、或环境变量覆盖），方便在不同环境下运行。
* **异常隔离**：单个文件的解析崩溃（虽然 C 解析器设计得很健壮）不会导致整个脚本中断。Python 脚本会捕获子进程的错误输出，记录错误日志，并继续处理其他文件。

**D. 结果聚合 (Result Aggregation)**
* **流式收集**：实时收集各个子进程输出的 JSON 片段。
* **统一输出**：将分散的结果合并为两个主文件：
    * `fc.json`：包含函数定义的有效文件。
    * `null_fc.json`：空文件或无函数文件。

### 构建脚本 (Build Script) - `Makefile`

`Makefile` 负责项目的自动化构建、编译、清理和安装。它精确定义了 Flex、Bison 和 GCC 之间的依赖关系链，确保每次构建都是准确且高效的。

#### 核心任务

**A. 代码生成流水线 (Code Generation Pipeline)**

* **Bison 阶段**：将 `src/parser.y` 编译为 `build/parser.tab.c` 和头文件 `build/parser.tab.h`。
* **Flex 阶段**：将 `src/lexer.l` 编译为 `build/lex.yy.c`。
* **依赖保障**：明确声明了 `lex.yy.c` 依赖于 `parser.tab.h`，防止因 Token 定义文件未生成而导致的编译错误。

**B. 联合编译 (Joint Compilation)**
* **多模块链接**：将自动生成的 C 代码（Lexer/Parser）与手写的 C 代码（`cfc_parser.c`, `utils.c`）进行联合编译。
* **头文件路径**：通过 `-Isrc -Ibuild` 参数，解决了生成代码与手写代码分散在不同目录下的头文件引用问题。
* **库依赖**：自动链接 `libfl` (Flex 库)。

**C. 部署管理 (Deployment)**

* **标准化安装**：提供 `make install` 目标，将 Python 驱动脚本和 C 二进制程序安装至 `/usr/local/bin`，并自动设置可执行权限。
* **环境清理**：`make clean` 可一键移除所有构建中间产物，保持项目目录整洁。

#### 构建流程
1. `make compile` -> 检测 `build/` 目录。
2. 调用 `bison` -> 生成 `parser.tab.c/h`。
3. 调用 `flex` -> 生成 `lex.yy.c`。
4. 调用 `gcc` -> 编译所有 `.c` 文件 -> 生成 `build/cfc_parser`。
5. 复制脚本 -> 生成 `bin/parsercfc`。

## 安装、使用介绍

### 环境要求

- **操作系统**：Linux (Ubuntu 20.04+, CentOS 7+ 等)
- **构建工具**：`gcc`, `make`
- **解析器生成器**：`flex`, `bison`
- **脚本环境**：`python3`

### 安装

Bash

```
sudo make
```

### 使用方法

**基本语法**：

Bash

```
parsercfc [选项] <目标源代码目录>
```

终端执行`parsercfc -h`将打印以下提示信息

```
usage: parsercfc [-h] [-w WORKERS] [-o-fc OUTPUT_FC] [-o-null_fc OUTPUT_NULL_FC] dir

C语言函数名提取工具。 扫描指定目录下的所有.c文件，提取函数定义。 结果输出到 fc.json (有函数) 和 null_fc.json (无函数)。

positional arguments:
  dir                   [必选] 要解析的源代码目录路径

options:
  -h, --help            show this help message and exit
  -w WORKERS, --workers WORKERS
                        使用的进程数 (默认为 CPU核心数-1: 11)
  -o-fc OUTPUT_FC       fc.json 的生成路径 (默认: 当前目录下 fc.json)
  -o-null_fc OUTPUT_NULL_FC
                        null_fc.json 的生成路径 (默认: 当前目录下 null_fc.json)
```

**使用示例**：

Bash

```
# 扫描FFmpeg工程
parsercfc /home/rkm/work/FFmpeg

# 扫描FFmpeg工程，如果需要记录运行信息，可执行
parsercfc /home/rkm/work/FFmpeg > run.log

# 指定进程数量、输出文件路径
parsercfc /home/rkm/work/FFmpeg -w 8 -o-fc ~/fc.json -o-null_fc ~/null_fc.json
```

### 结果输出格式

**fc.json (包含函数定义的文件)**：

JSON

```
{
  "/home/rkm/work/FFmpeg/compat/android/binder.c": {
    "fc": [
      "dlopen_libbinder_ndk",
      "android_binder_threadpool_init",
      "android_binder_threadpool_init_if_required"
    ]
  },
  "/home/rkm/work/FFmpeg/compat/djgpp/math.c": {
    "fc": [
      "fmin",
      "fmax",
      "fminf",
      "fmaxf",
      "fmodl",
      "scalbnl",
      "copysignl"
    ]
  },
  ...此处省略...
}
```

**null_fc.json (未检测到函数定义的文件)**：

JSON

```
[
  "/home/rkm/work/FFmpeg/libavcodec/aacenctab.c",
  "/home/rkm/work/FFmpeg/libavcodec/aacps_fixed.c",
  ...此处省略...
]
```

## 测试
以业界公认复杂的 **FFmpeg** 多媒体框架源代码为例，验证解析器的性能与准确性。
### 测试环境
![](images/win10硬件.PNG)
![](images/win10-WSL2系统.PNG)
![](images/WSL-Setting.PNG)

### 性能表现-run.log

#### 默认参数

执行`parsercfc /home/rkm/work/FFmpeg > run.log`

```
Scan dir: /home/rkm/work/FFmpeg
Workers: 11
Found 3340 .c files
Output fc.json: fc.json
Output null_fc.json: null_fc.json
[3340/3340] 100.0% elapsed 0.2s
Done.
Elapsed: 0.21s
Total files: 3340
Total functions: 31433
Files with no functions: 172
```

#### -w 1

执行`parsercfc -w 1 /home/rkm/work/FFmpeg > run-w-1.log`

```
Scan dir: /home/rkm/work/FFmpeg
Workers: 1
Found 3340 .c files
Output fc.json: fc.json
Output null_fc.json: null_fc.json
[3340/3340] 100.0% elapsed 0.6s
Done.
Elapsed: 0.57s
Total files: 3340
Total functions: 31433
Files with no functions: 172
```

#### -w 64

执行`parsercfc -w 64 /home/rkm/work/FFmpeg > run-w-64.log`

```
Scan dir: /home/rkm/work/FFmpeg
Workers: 64
Found 3340 .c files
Output fc.json: fc.json
Output null_fc.json: null_fc.json
[2171/3340] 65.0% elapsed 0.2s
[3340/3340] 100.0% elapsed 0.2s
Done.
Elapsed: 0.23s
Total files: 3340
Total functions: 31433
Files with no functions: 172
```



### 复杂案例验证

#### 自定义类型

![](images/自定义类型.PNG)

#### 宏定义与复杂参数列表

![](images/宏定义与复杂参数列表.PNG)

#### 宏定义拼接函数

![](images/宏定义拼接函数.PNG)

#### 任意插入注释回车

![](images/任意插入注释回车.PNG)

### 结论

经测试，该工具初步已实现既定目标，后续仍需进行更专业的测试与改进。
