# 解析器 parsercfc 开发计划

## 1. 目标与范围
1. 在 Linux 下实现 C 语言函数定义解析工具 `parsercfc`。  
2. 输入：指定目录，递归查找所有 `.c` 文件。  
3. 输出：  
   - `fc.json`：每个 `.c` 文件路径对应一个对象，包含函数名列表 `"fc":[...]`。  
   - `null_fc.json`：收集无函数定义的 `.c` 文件路径（要求也在 `fc.json` 中以空列表保存）。  
4. 运行时信息：进度、耗时、解析文件总数、函数总数、无函数文件数等。  
5. 采用 Flex & Bison 做词法/语法解析，Python 负责多进程/多线程调度与结果聚合。  
6. 提供 Makefile 支持一键编译安装与清理。

## 2. 总体流程与技术选型
### 2.1 流程概览
1. 命令行解析：读取目录、线程数、输出路径参数。  
2. 文件发现：递归扫描 `.c` 文件列表。  
3. 并行解析：多进程（或进程池）调用解析器，对每个文件提取函数名。  
4. 结果聚合：合并到 `fc.json` 和 `null_fc.json`。  
5. 统计与日志：输出进度、耗时、统计信息。  

### 2.2 技术/工具
- **Flex**：定义 C 语言相关词法规则（关键字、标识符、符号、注释处理等）。  
- **Bison**：定义函数定义的语法规则，捕获函数名。  
- **Python**：  
  - `argparse` 处理 CLI 参数  
  - `multiprocessing`/`concurrent.futures` 实现并行  
  - `json` 输出  
  - `time` 统计耗时  
- **Makefile**：统一构建与清理。  
- **Linux**：目标运行环境。

## 3. 详细开发步骤
### 3.1 需求细化与输出格式定义
1. 明确函数定义识别范围：  
   - 仅统计“函数定义”，不统计函数声明。  
   - 对不规范但能编译通过的 C 代码进行容错。  
2. 定义 `fc.json` 数据格式示例：  
   ```json
   {
     "/abs/path/a.c": {"fc": ["foo", "bar"]},
     "/abs/path/b.c": {"fc": []}
   }
   ```  
3. 定义 `null_fc.json` 数据格式：  
   ```json
   ["/abs/path/b.c", "/abs/path/c.c"]
   ```

### 3.2 词法规则（Flex）
1. 处理 C 标识符、关键字、符号、字符串、字符常量。  
2. 忽略注释（`//` 与 `/* */`）。  
3. 将标识符与关键符号传递给 Bison。  
4. 需要能容错处理不规范空格、换行。

### 3.3 语法规则（Bison）
1. 定义函数定义的模式：  
   - 允许复杂返回类型（指针、结构体、限定符等）。  
   - 允许参数列表为空或复杂参数类型。  
2. 当识别到函数定义时，记录函数名。  
3. 避免误识别宏或函数声明。  

### 3.4 解析器集成
1. 生成 `lex.yy.c` 与 `parser.tab.c`。  
2. 提供 C 入口函数：  
   - 接收单个 `.c` 文件路径  
   - 返回函数名列表  
3. 将结果输出给 Python 端（可通过标准输出、临时文件或 FFI 调用方式）。  
   - 优先标准输出 JSON 行或简单文本列表，便于聚合。

### 3.5 Python 调度与并行
1. 递归收集 `.c` 文件路径。  
2. 使用 `multiprocessing.Pool` / `concurrent.futures.ProcessPoolExecutor` 分发解析任务。  
3. 参数 `-w/--workers` 控制并行度，默认 `CPU核数-1`。  
4. 进度显示（例如处理完成数/总数）。  
5. 汇总：  
   - `fc.json` 包含所有 `.c` 文件  
   - 函数列表为空的路径放入 `null_fc.json`

### 3.6 运行时统计与日志
1. 记录开始与结束时间，输出总耗时。  
2. 统计：  
   - 文件总数  
   - 函数总数  
   - 无函数文件数  
3. 输出到终端（stdout）。

### 3.7 Makefile 与项目结构
1. `make`：  
   - 生成 Flex/Bison 代码  
   - 编译 C 解析器  
   - 安装 `parsercfc`（可复制到 `bin/` 或生成可执行入口）  
2. `make clean`：  
   - 删除生成文件与临时文件  
3. 文档统一放在 `doc/` 目录。
4. 约定测试目录结构：  
   - `test/in/`：存放待扫描的工程  
   - `test/out/`：存放 `fc.json`、`null_fc.json` 和运行日志（解析命令的终端输出内容），并纳入版本控制以便查看

## 4. 测试与验证
1. 准备不同风格 C 文件样本：  
   - 正常函数定义  
   - 复杂返回类型  
   - 多行函数头  
   - 无函数文件  
2. 选择著名的 FFmpeg 工程作为大规模测试样本，拷贝到 `test/in/FFmpeg`。  
3. 验证输出 JSON 格式正确，并将输出写入 `test/out/`。  
4. 验证统计与日志信息完整，并保存终端输出到 `test/out/`。  
5. 并行处理稳定性与性能测试。

## 5. 里程碑与交付物
1. **阶段 1：解析器原型**  
   - Flex/Bison 规则  
   - 单文件解析验证  
2. **阶段 2：并行调度与输出**  
   - Python 调度  
   - JSON 输出  
3. **阶段 3：CLI & Makefile**  
   - `parsercfc -h` 帮助  
   - `make` / `make clean`  
4. **阶段 4：测试与完善**  
   - 多样化样例  
   - 性能与稳定性优化  

## 6. 风险与应对
1. C 语法复杂性高：  
   - 聚焦函数定义场景，逐步扩展规则覆盖面。  
2. 宏与预处理影响：  
   - 先忽略宏展开，仅解析原始源码。  
3. 并行调度瓶颈：  
   - 控制进程数，避免过高开销。  

---
该计划覆盖了从需求分析到实现、测试、交付的完整流程，可作为后续开发的执行依据。
